{"version":3,"file":"polygon-offset.min.js","sources":["../src/edge.js","../node_modules/martinez-polygon-clipping/src/edge_type.js","../node_modules/tinyqueue/index.js","../node_modules/bintrees/lib/treebase.js","../node_modules/bintrees/lib/rbtree.js","../node_modules/bintrees/lib/bintree.js","../node_modules/bintrees/index.js","../node_modules/martinez-polygon-clipping/src/signed_area.js","../node_modules/martinez-polygon-clipping/src/sweep_event.js","../node_modules/martinez-polygon-clipping/src/compare_events.js","../node_modules/martinez-polygon-clipping/src/equals.js","../node_modules/martinez-polygon-clipping/src/compare_segments.js","../node_modules/martinez-polygon-clipping/src/segment_intersection.js","../node_modules/martinez-polygon-clipping/src/index.js","../node_modules/martinez-polygon-clipping/index.js","../src/utils.js","../src/offset.js"],"sourcesContent":["const invert = ([a, b]) => [-a, -b];\n\n/**\n * Offset edge of the polygon\n *\n * @param  {Object} current\n * @param  {Object} next\n */\nexport default class Edge {\n\n  constructor (current, next) {\n\n    /**\n     * @type {Object}\n     */\n    this.current = current;\n\n    /**\n     * @type {Object}\n     */\n    this.next = next;\n\n    /**\n     * @type {Object}\n     */\n    this.inNormal  = this.inwardsNormal();\n\n    /**\n     * @type {Object}\n     */\n    this.outNormal = invert(this.inNormal);\n  }\n\n  /**\n   * Creates inwards normal\n   * @return {Object}\n   */\n  inwardsNormal () {\n    const dx = this.next[0] - this.current[0];\n    const dy = this.next[1] - this.current[1];\n    const edgeLength = Math.sqrt(dx * dx + dy * dy);\n\n    if (edgeLength === 0) throw new Error('Vertices overlap');\n\n    return [\n      -dy / edgeLength,\n      dx / edgeLength\n    ];\n  }\n\n  /**\n   * Offsets the edge by dx, dy\n   * @param  {Number} dx\n   * @param  {Number} dy\n   * @return {Edge}\n   */\n  offset (dx, dy) {\n    return offsetEdge(this.current, this.next, dx, dy);\n  }\n\n\n  /**\n   * @param  {Number} dx\n   * @param  {Number} dy\n   * @return {Edge}\n   */\n  inverseOffset (dx, dy) {\n    return offsetEdge(this.next, this.current, dx, dy);\n  }\n\n\n  /**\n   * @return {Edge}\n   */\n  inverse () {\n    return new Edge(this.next, this.current);\n  }\n}\n\n\nconst offsetEdge = (current, next, dx, dy) => new Edge([\n    current[0] + dx,\n    current[1] + dy\n  ], [\n    next[0] + dx,\n    next[1] + dy\n  ]);\n","module.exports = { \n  NORMAL:               0, \n  NON_CONTRIBUTING:     1, \n  SAME_TRANSITION:      2, \n  DIFFERENT_TRANSITION: 3\n};\n","'use strict';\n\nmodule.exports = TinyQueue;\nmodule.exports.default = TinyQueue;\n\nfunction TinyQueue(data, compare) {\n    if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);\n\n    this.data = data || [];\n    this.length = this.data.length;\n    this.compare = compare || defaultCompare;\n\n    if (this.length > 0) {\n        for (var i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nTinyQueue.prototype = {\n\n    push: function (item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    },\n\n    pop: function () {\n        if (this.length === 0) return undefined;\n\n        var top = this.data[0];\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = this.data[this.length];\n            this._down(0);\n        }\n        this.data.pop();\n\n        return top;\n    },\n\n    peek: function () {\n        return this.data[0];\n    },\n\n    _up: function (pos) {\n        var data = this.data;\n        var compare = this.compare;\n        var item = data[pos];\n\n        while (pos > 0) {\n            var parent = (pos - 1) >> 1;\n            var current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    },\n\n    _down: function (pos) {\n        var data = this.data;\n        var compare = this.compare;\n        var halfLength = this.length >> 1;\n        var item = data[pos];\n\n        while (pos < halfLength) {\n            var left = (pos << 1) + 1;\n            var right = left + 1;\n            var best = data[left];\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n};\n","\nfunction TreeBase() {}\n\n// removes all nodes from the tree\nTreeBase.prototype.clear = function() {\n    this._root = null;\n    this.size = 0;\n};\n\n// returns node data if found, null otherwise\nTreeBase.prototype.find = function(data) {\n    var res = this._root;\n\n    while(res !== null) {\n        var c = this._comparator(data, res.data);\n        if(c === 0) {\n            return res.data;\n        }\n        else {\n            res = res.get_child(c > 0);\n        }\n    }\n\n    return null;\n};\n\n// returns iterator to node if found, null otherwise\nTreeBase.prototype.findIter = function(data) {\n    var res = this._root;\n    var iter = this.iterator();\n\n    while(res !== null) {\n        var c = this._comparator(data, res.data);\n        if(c === 0) {\n            iter._cursor = res;\n            return iter;\n        }\n        else {\n            iter._ancestors.push(res);\n            res = res.get_child(c > 0);\n        }\n    }\n\n    return null;\n};\n\n// Returns an iterator to the tree node at or immediately after the item\nTreeBase.prototype.lowerBound = function(item) {\n    var cur = this._root;\n    var iter = this.iterator();\n    var cmp = this._comparator;\n\n    while(cur !== null) {\n        var c = cmp(item, cur.data);\n        if(c === 0) {\n            iter._cursor = cur;\n            return iter;\n        }\n        iter._ancestors.push(cur);\n        cur = cur.get_child(c > 0);\n    }\n\n    for(var i=iter._ancestors.length - 1; i >= 0; --i) {\n        cur = iter._ancestors[i];\n        if(cmp(item, cur.data) < 0) {\n            iter._cursor = cur;\n            iter._ancestors.length = i;\n            return iter;\n        }\n    }\n\n    iter._ancestors.length = 0;\n    return iter;\n};\n\n// Returns an iterator to the tree node immediately after the item\nTreeBase.prototype.upperBound = function(item) {\n    var iter = this.lowerBound(item);\n    var cmp = this._comparator;\n\n    while(iter.data() !== null && cmp(iter.data(), item) === 0) {\n        iter.next();\n    }\n\n    return iter;\n};\n\n// returns null if tree is empty\nTreeBase.prototype.min = function() {\n    var res = this._root;\n    if(res === null) {\n        return null;\n    }\n\n    while(res.left !== null) {\n        res = res.left;\n    }\n\n    return res.data;\n};\n\n// returns null if tree is empty\nTreeBase.prototype.max = function() {\n    var res = this._root;\n    if(res === null) {\n        return null;\n    }\n\n    while(res.right !== null) {\n        res = res.right;\n    }\n\n    return res.data;\n};\n\n// returns a null iterator\n// call next() or prev() to point to an element\nTreeBase.prototype.iterator = function() {\n    return new Iterator(this);\n};\n\n// calls cb on each node's data, in order\nTreeBase.prototype.each = function(cb) {\n    var it=this.iterator(), data;\n    while((data = it.next()) !== null) {\n        if(cb(data) === false) {\n            return;\n        }\n    }\n};\n\n// calls cb on each node's data, in reverse order\nTreeBase.prototype.reach = function(cb) {\n    var it=this.iterator(), data;\n    while((data = it.prev()) !== null) {\n        if(cb(data) === false) {\n            return;\n        }\n    }\n};\n\n\nfunction Iterator(tree) {\n    this._tree = tree;\n    this._ancestors = [];\n    this._cursor = null;\n}\n\nIterator.prototype.data = function() {\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\n// if null-iterator, returns first node\n// otherwise, returns next node\nIterator.prototype.next = function() {\n    if(this._cursor === null) {\n        var root = this._tree._root;\n        if(root !== null) {\n            this._minNode(root);\n        }\n    }\n    else {\n        if(this._cursor.right === null) {\n            // no greater node in subtree, go up to parent\n            // if coming from a right child, continue up the stack\n            var save;\n            do {\n                save = this._cursor;\n                if(this._ancestors.length) {\n                    this._cursor = this._ancestors.pop();\n                }\n                else {\n                    this._cursor = null;\n                    break;\n                }\n            } while(this._cursor.right === save);\n        }\n        else {\n            // get the next node from the subtree\n            this._ancestors.push(this._cursor);\n            this._minNode(this._cursor.right);\n        }\n    }\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\n// if null-iterator, returns last node\n// otherwise, returns previous node\nIterator.prototype.prev = function() {\n    if(this._cursor === null) {\n        var root = this._tree._root;\n        if(root !== null) {\n            this._maxNode(root);\n        }\n    }\n    else {\n        if(this._cursor.left === null) {\n            var save;\n            do {\n                save = this._cursor;\n                if(this._ancestors.length) {\n                    this._cursor = this._ancestors.pop();\n                }\n                else {\n                    this._cursor = null;\n                    break;\n                }\n            } while(this._cursor.left === save);\n        }\n        else {\n            this._ancestors.push(this._cursor);\n            this._maxNode(this._cursor.left);\n        }\n    }\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\nIterator.prototype._minNode = function(start) {\n    while(start.left !== null) {\n        this._ancestors.push(start);\n        start = start.left;\n    }\n    this._cursor = start;\n};\n\nIterator.prototype._maxNode = function(start) {\n    while(start.right !== null) {\n        this._ancestors.push(start);\n        start = start.right;\n    }\n    this._cursor = start;\n};\n\nmodule.exports = TreeBase;\n\n","\nvar TreeBase = require('./treebase');\n\nfunction Node(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n    this.red = true;\n}\n\nNode.prototype.get_child = function(dir) {\n    return dir ? this.right : this.left;\n};\n\nNode.prototype.set_child = function(dir, val) {\n    if(dir) {\n        this.right = val;\n    }\n    else {\n        this.left = val;\n    }\n};\n\nfunction RBTree(comparator) {\n    this._root = null;\n    this._comparator = comparator;\n    this.size = 0;\n}\n\nRBTree.prototype = new TreeBase();\n\n// returns true if inserted, false if duplicate\nRBTree.prototype.insert = function(data) {\n    var ret = false;\n\n    if(this._root === null) {\n        // empty tree\n        this._root = new Node(data);\n        ret = true;\n        this.size++;\n    }\n    else {\n        var head = new Node(undefined); // fake tree root\n\n        var dir = 0;\n        var last = 0;\n\n        // setup\n        var gp = null; // grandparent\n        var ggp = head; // grand-grand-parent\n        var p = null; // parent\n        var node = this._root;\n        ggp.right = this._root;\n\n        // search down\n        while(true) {\n            if(node === null) {\n                // insert new node at the bottom\n                node = new Node(data);\n                p.set_child(dir, node);\n                ret = true;\n                this.size++;\n            }\n            else if(is_red(node.left) && is_red(node.right)) {\n                // color flip\n                node.red = true;\n                node.left.red = false;\n                node.right.red = false;\n            }\n\n            // fix red violation\n            if(is_red(node) && is_red(p)) {\n                var dir2 = ggp.right === gp;\n\n                if(node === p.get_child(last)) {\n                    ggp.set_child(dir2, single_rotate(gp, !last));\n                }\n                else {\n                    ggp.set_child(dir2, double_rotate(gp, !last));\n                }\n            }\n\n            var cmp = this._comparator(node.data, data);\n\n            // stop if found\n            if(cmp === 0) {\n                break;\n            }\n\n            last = dir;\n            dir = cmp < 0;\n\n            // update helpers\n            if(gp !== null) {\n                ggp = gp;\n            }\n            gp = p;\n            p = node;\n            node = node.get_child(dir);\n        }\n\n        // update root\n        this._root = head.right;\n    }\n\n    // make root black\n    this._root.red = false;\n\n    return ret;\n};\n\n// returns true if removed, false if not found\nRBTree.prototype.remove = function(data) {\n    if(this._root === null) {\n        return false;\n    }\n\n    var head = new Node(undefined); // fake tree root\n    var node = head;\n    node.right = this._root;\n    var p = null; // parent\n    var gp = null; // grand parent\n    var found = null; // found item\n    var dir = 1;\n\n    while(node.get_child(dir) !== null) {\n        var last = dir;\n\n        // update helpers\n        gp = p;\n        p = node;\n        node = node.get_child(dir);\n\n        var cmp = this._comparator(data, node.data);\n\n        dir = cmp > 0;\n\n        // save found node\n        if(cmp === 0) {\n            found = node;\n        }\n\n        // push the red node down\n        if(!is_red(node) && !is_red(node.get_child(dir))) {\n            if(is_red(node.get_child(!dir))) {\n                var sr = single_rotate(node, dir);\n                p.set_child(last, sr);\n                p = sr;\n            }\n            else if(!is_red(node.get_child(!dir))) {\n                var sibling = p.get_child(!last);\n                if(sibling !== null) {\n                    if(!is_red(sibling.get_child(!last)) && !is_red(sibling.get_child(last))) {\n                        // color flip\n                        p.red = false;\n                        sibling.red = true;\n                        node.red = true;\n                    }\n                    else {\n                        var dir2 = gp.right === p;\n\n                        if(is_red(sibling.get_child(last))) {\n                            gp.set_child(dir2, double_rotate(p, last));\n                        }\n                        else if(is_red(sibling.get_child(!last))) {\n                            gp.set_child(dir2, single_rotate(p, last));\n                        }\n\n                        // ensure correct coloring\n                        var gpc = gp.get_child(dir2);\n                        gpc.red = true;\n                        node.red = true;\n                        gpc.left.red = false;\n                        gpc.right.red = false;\n                    }\n                }\n            }\n        }\n    }\n\n    // replace and remove if found\n    if(found !== null) {\n        found.data = node.data;\n        p.set_child(p.right === node, node.get_child(node.left === null));\n        this.size--;\n    }\n\n    // update root and make it black\n    this._root = head.right;\n    if(this._root !== null) {\n        this._root.red = false;\n    }\n\n    return found !== null;\n};\n\nfunction is_red(node) {\n    return node !== null && node.red;\n}\n\nfunction single_rotate(root, dir) {\n    var save = root.get_child(!dir);\n\n    root.set_child(!dir, save.get_child(dir));\n    save.set_child(dir, root);\n\n    root.red = true;\n    save.red = false;\n\n    return save;\n}\n\nfunction double_rotate(root, dir) {\n    root.set_child(!dir, single_rotate(root.get_child(!dir), !dir));\n    return single_rotate(root, dir);\n}\n\nmodule.exports = RBTree;\n","\nvar TreeBase = require('./treebase');\n\nfunction Node(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n}\n\nNode.prototype.get_child = function(dir) {\n    return dir ? this.right : this.left;\n};\n\nNode.prototype.set_child = function(dir, val) {\n    if(dir) {\n        this.right = val;\n    }\n    else {\n        this.left = val;\n    }\n};\n\nfunction BinTree(comparator) {\n    this._root = null;\n    this._comparator = comparator;\n    this.size = 0;\n}\n\nBinTree.prototype = new TreeBase();\n\n// returns true if inserted, false if duplicate\nBinTree.prototype.insert = function(data) {\n    if(this._root === null) {\n        // empty tree\n        this._root = new Node(data);\n        this.size++;\n        return true;\n    }\n\n    var dir = 0;\n\n    // setup\n    var p = null; // parent\n    var node = this._root;\n\n    // search down\n    while(true) {\n        if(node === null) {\n            // insert new node at the bottom\n            node = new Node(data);\n            p.set_child(dir, node);\n            ret = true;\n            this.size++;\n            return true;\n        }\n\n        // stop if found\n        if(this._comparator(node.data, data) === 0) {\n            return false;\n        }\n\n        dir = this._comparator(node.data, data) < 0;\n\n        // update helpers\n        p = node;\n        node = node.get_child(dir);\n    }\n};\n\n// returns true if removed, false if not found\nBinTree.prototype.remove = function(data) {\n    if(this._root === null) {\n        return false;\n    }\n\n    var head = new Node(undefined); // fake tree root\n    var node = head;\n    node.right = this._root;\n    var p = null; // parent\n    var found = null; // found item\n    var dir = 1;\n\n    while(node.get_child(dir) !== null) {\n        p = node;\n        node = node.get_child(dir);\n        var cmp = this._comparator(data, node.data);\n        dir = cmp > 0;\n\n        if(cmp === 0) {\n            found = node;\n        }\n    }\n\n    if(found !== null) {\n        found.data = node.data;\n        p.set_child(p.right === node, node.get_child(node.left === null));\n\n        this._root = head.right;\n        this.size--;\n        return true;\n    }\n    else {\n        return false;\n    }\n};\n\nmodule.exports = BinTree;\n\n","module.exports = {\n    RBTree: require('./lib/rbtree'),\n    BinTree: require('./lib/bintree')\n};\n","/**\n * Signed area of the triangle (p0, p1, p2)\n * @param  {Array.<Number>} p0\n * @param  {Array.<Number>} p1\n * @param  {Array.<Number>} p2\n * @return {Number}\n */\nmodule.exports = function signedArea(p0, p1, p2) {\n  return (p0[0] - p2[0]) * (p1[1] - p2[1]) - (p1[0] - p2[0]) * (p0[1] - p2[1]);\n};\n","var signedArea = require('./signed_area');\nvar EdgeType   = require('./edge_type');\n\n\n/**\n * Sweepline event\n *\n * @param {Array.<Number>}  point\n * @param {Boolean}         left\n * @param {SweepEvent=}     otherEvent\n * @param {Boolean}         isSubject\n * @param {Number}          edgeType\n */\nfunction SweepEvent(point, left, otherEvent, isSubject, edgeType) {\n\n  /**\n   * Is left endpoint?\n   * @type {Boolean}\n   */\n  this.left = left;\n\n  /**\n   * @type {Array.<Number>}\n   */\n  this.point = point;\n\n  /**\n   * Other edge reference\n   * @type {SweepEvent}\n   */\n  this.otherEvent = otherEvent;\n\n  /**\n   * Belongs to source or clipping polygon\n   * @type {Boolean}\n   */\n  this.isSubject = isSubject;\n\n  /**\n   * Edge contribution type\n   * @type {Number}\n   */\n  this.type = edgeType || EdgeType.NORMAL;\n\n\n  /**\n   * In-out transition for the sweepline crossing polygon\n   * @type {Boolean}\n   */\n  this.inOut = false;\n\n\n  /**\n   * @type {Boolean}\n   */\n  this.otherInOut = false;\n\n  /**\n   * Previous event in result?\n   * @type {SweepEvent}\n   */\n  this.prevInResult = null;\n\n  /**\n   * Does event belong to result?\n   * @type {Boolean}\n   */\n  this.inResult = false;\n\n\n  // connection step\n\n  /**\n   * @type {Boolean}\n   */\n  this.resultInOut = false;\n}\n\n\nSweepEvent.prototype = {\n\n  /**\n   * @param  {Array.<Number>}  p\n   * @return {Boolean}\n   */\n  isBelow: function(p) {\n    return this.left ?\n      signedArea (this.point, this.otherEvent.point, p) > 0 :\n      signedArea (this.otherEvent.point, this.point, p) > 0;\n  },\n\n\n  /**\n   * @param  {Array.<Number>}  p\n   * @return {Boolean}\n   */\n  isAbove: function(p) {\n    return !this.isBelow(p);\n  },\n\n\n  /**\n   * @return {Boolean}\n   */\n  isVertical: function() {\n    return this.point[0] === this.otherEvent.point[0];\n  }\n};\n\nmodule.exports = SweepEvent;\n","var signedArea = require('./signed_area');\n// var equals = require('./equals');\n\n/**\n * @param  {SweepEvent} e1\n * @param  {SweepEvent} e2\n * @return {Number}\n */\nmodule.exports = function sweepEventsComp(e1, e2) {\n  var p1 = e1.point;\n  var p2 = e2.point;\n\n  // Different x-coordinate\n  if (p1[0] > p2[0]) return 1;\n  if (p1[0] < p2[0]) return -1;\n\n  // Different points, but same x-coordinate\n  // Event with lower y-coordinate is processed first\n  if (p1[1] !== p2[1]) return p1[1] > p2[1] ? 1 : -1;\n\n  return specialCases(e1, e2, p1, p2);\n};\n\n\nfunction specialCases(e1, e2, p1, p2) {\n  // Same coordinates, but one is a left endpoint and the other is\n  // a right endpoint. The right endpoint is processed first\n  if (e1.left !== e2.left)\n    return e1.left ? 1 : -1;\n\n  // Same coordinates, both events\n  // are left endpoints or right endpoints.\n  // not collinear\n  if (signedArea (p1, e1.otherEvent.point, e2.otherEvent.point) !== 0) {\n    // the event associate to the bottom segment is processed first\n    return (!e1.isBelow(e2.otherEvent.point)) ? 1 : -1;\n  }\n\n  // uncomment this if you want to play with multipolygons\n  // if (e1.isSubject === e2.isSubject) {\n  //   if(equals(e1.point, e2.point) && e1.contourId === e2.contourId) {\n  //     return 0;\n  //   } else {\n  //     return e1.contourId > e2.contourId ? 1 : -1;\n  //   }\n  // }\n\n  return (!e1.isSubject && e2.isSubject) ? 1 : -1;\n}\n","module.exports = function equals(p1, p2) {\n  return p1[0] === p2[0] && p1[1] === p2[1];\n};","var signedArea    = require('./signed_area');\nvar compareEvents = require('./compare_events');\nvar equals        = require('./equals');\n\n\n/**\n * @param  {SweepEvent} le1\n * @param  {SweepEvent} le2\n * @return {Number}\n */\nmodule.exports = function compareSegments(le1, le2) {\n  if (le1 === le2) return 0;\n\n  // Segments are not collinear\n  if (signedArea(le1.point, le1.otherEvent.point, le2.point) !== 0 ||\n    signedArea(le1.point, le1.otherEvent.point, le2.otherEvent.point) !== 0) {\n\n    // If they share their left endpoint use the right endpoint to sort\n    if (equals(le1.point, le2.point)) return le1.isBelow(le2.otherEvent.point) ? -1 : 1;\n\n    // Different left endpoint: use the left endpoint to sort\n    if (le1.point[0] === le2.point[0]) return le1.point[1] < le2.point[1] ? -1 : 1;\n\n    // has the line segment associated to e1 been inserted\n    // into S after the line segment associated to e2 ?\n    if (compareEvents(le1, le2) === 1) return le2.isAbove(le1.point) ? -1 : 1;\n\n    // The line segment associated to e2 has been inserted\n    // into S after the line segment associated to e1\n    return le1.isBelow(le2.point) ? -1 : 1;\n  }\n\n  if (le1.isSubject === le2.isSubject) { // same polygon\n    if (equals(le1.point, le2.point)) {\n      if (equals(le1.otherEvent.point, le2.otherEvent.point)) {\n        return 0;\n      } else {\n        return le1.contourId > le2.contourId ? 1 : -1;\n      }\n    }\n  } else { // Segments are collinear, but belong to separate polygons\n    return le1.isSubject ? -1 : 1;\n  }\n\n  return compareEvents(le1, le2) === 1 ? 1 : -1;\n};\n","var EPSILON = 1e-9;\n\n/**\n * Finds the magnitude of the cross product of two vectors (if we pretend\n * they're in three dimensions)\n *\n * @param {Object} a First vector\n * @param {Object} b Second vector\n * @private\n * @returns {Number} The magnitude of the cross product\n */\nfunction krossProduct(a, b) {\n  return a[0] * b[1] - a[1] * b[0];\n}\n\n/**\n * Finds the dot product of two vectors.\n *\n * @param {Object} a First vector\n * @param {Object} b Second vector\n * @private\n * @returns {Number} The dot product\n */\nfunction dotProduct(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n\n/**\n * Finds the intersection (if any) between two line segments a and b, given the\n * line segments' end points a1, a2 and b1, b2.\n *\n * This algorithm is based on Schneider and Eberly.\n * http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf\n * Page 244.\n *\n * @param {Array.<Number>} a1 point of first line\n * @param {Array.<Number>} a2 point of first line\n * @param {Array.<Number>} b1 point of second line\n * @param {Array.<Number>} b2 point of second line\n * @param {Boolean=}       noEndpointTouch whether to skip single touchpoints\n *                                         (meaning connected segments) as\n *                                         intersections\n * @returns {Array.<Array.<Number>>|Null} If the lines intersect, the point of\n * intersection. If they overlap, the two end points of the overlapping segment.\n * Otherwise, null.\n */\nmodule.exports = function(a1, a2, b1, b2, noEndpointTouch) {\n  // The algorithm expects our lines in the form P + sd, where P is a point,\n  // s is on the interval [0, 1], and d is a vector.\n  // We are passed two points. P can be the first point of each pair. The\n  // vector, then, could be thought of as the distance (in x and y components)\n  // from the first point to the second point.\n  // So first, let's make our vectors:\n  var va = [a2[0] - a1[0], a2[1] - a1[1]];\n  var vb = [b2[0] - b1[0], b2[1] - b1[1]];\n  // We also define a function to convert back to regular point form:\n\n  /* eslint-disable arrow-body-style */\n\n  function toPoint(p, s, d) {\n    return [\n      p[0] + s * d[0],\n      p[1] + s * d[1]\n    ];\n  }\n\n  /* eslint-enable arrow-body-style */\n\n  // The rest is pretty much a straight port of the algorithm.\n  var e = [b1[0] - a1[0], b1[1] - a1[1]];\n  var kross = krossProduct(va, vb);\n  var sqrKross = kross * kross;\n  var sqrLenA = dotProduct(va, va);\n  var sqrLenB = dotProduct(vb, vb);\n\n  // Check for line intersection. This works because of the properties of the\n  // cross product -- specifically, two vectors are parallel if and only if the\n  // cross product is the 0 vector. The full calculation involves relative error\n  // to account for possible very small line segments. See Schneider & Eberly\n  // for details.\n  if (sqrKross > EPSILON * sqrLenA * sqrLenB) {\n    // If they're not parallel, then (because these are line segments) they\n    // still might not actually intersect. This code checks that the\n    // intersection point of the lines is actually on both line segments.\n    var s = krossProduct(e, vb) / kross;\n    if (s < 0 || s > 1) {\n      // not on line segment a\n      return null;\n    }\n    var t = krossProduct(e, va) / kross;\n    if (t < 0 || t > 1) {\n      // not on line segment b\n      return null;\n    }\n    return noEndpointTouch ? null : [toPoint(a1, s, va)];\n  }\n\n  // If we've reached this point, then the lines are either parallel or the\n  // same, but the segments could overlap partially or fully, or not at all.\n  // So we need to find the overlap, if any. To do that, we can use e, which is\n  // the (vector) difference between the two initial points. If this is parallel\n  // with the line itself, then the two lines are the same line, and there will\n  // be overlap.\n  var sqrLenE = dotProduct(e, e);\n  kross = krossProduct(e, va);\n  sqrKross = kross * kross;\n\n  if (sqrKross > EPSILON * sqrLenA * sqrLenE) {\n    // Lines are just parallel, not the same. No overlap.\n    return null;\n  }\n\n  var sa = dotProduct(va, e) / sqrLenA;\n  var sb = sa + dotProduct(va, vb) / sqrLenA;\n  var smin = Math.min(sa, sb);\n  var smax = Math.max(sa, sb);\n\n  // this is, essentially, the FindIntersection acting on floats from\n  // Schneider & Eberly, just inlined into this function.\n  if (smin <= 1 && smax >= 0) {\n\n    // overlap on an end point\n    if (smin === 1) {\n      return noEndpointTouch ? null : [toPoint(a1, smin > 0 ? smin : 0, va)];\n    }\n\n    if (smax === 0) {\n      return noEndpointTouch ? null : [toPoint(a1, smax < 1 ? smax : 1, va)];\n    }\n\n    if (noEndpointTouch && smin === 0 && smax === 1) return null;\n\n    // There's overlap on a segment -- two points of intersection. Return both.\n    return [\n      toPoint(a1, smin > 0 ? smin : 0, va),\n      toPoint(a1, smax < 1 ? smax : 1, va),\n    ];\n  }\n\n  return null;\n};\n","var INTERSECTION    = 0;\nvar UNION           = 1;\nvar DIFFERENCE      = 2;\nvar XOR             = 3;\n\nvar EMPTY           = [];\n\nvar edgeType        = require('./edge_type');\n\nvar Queue           = require('tinyqueue');\nvar Tree            = require('bintrees').RBTree;\nvar SweepEvent      = require('./sweep_event');\n\nvar compareEvents   = require('./compare_events');\nvar compareSegments = require('./compare_segments');\nvar intersection    = require('./segment_intersection');\nvar equals          = require('./equals');\n\nvar max = Math.max;\nvar min = Math.min;\n\n// global.Tree = Tree;\n// global.compareSegments = compareSegments;\n// global.SweepEvent = SweepEvent;\n// global.signedArea = require('./signed_area');\n\n/**\n * @param  {<Array.<Number>} s1\n * @param  {<Array.<Number>} s2\n * @param  {Boolean}         isSubject\n * @param  {Queue}           eventQueue\n * @param  {Array.<Number>}  bbox\n */\nfunction processSegment(s1, s2, isSubject, depth, eventQueue, bbox) {\n  // Possible degenerate condition.\n  // if (equals(s1, s2)) return;\n\n  var e1 = new SweepEvent(s1, false, undefined, isSubject);\n  var e2 = new SweepEvent(s2, false, e1,        isSubject);\n  e1.otherEvent = e2;\n\n  e1.contourId = e2.contourId = depth;\n\n  if (compareEvents(e1, e2) > 0) {\n    e2.left = true;\n  } else {\n    e1.left = true;\n  }\n\n  bbox[0] = min(bbox[0], s1[0]);\n  bbox[1] = min(bbox[1], s1[1]);\n  bbox[2] = max(bbox[2], s1[0]);\n  bbox[3] = max(bbox[3], s1[1]);\n\n  // Pushing it so the queue is sorted from left to right,\n  // with object on the left having the highest priority.\n  eventQueue.push(e1);\n  eventQueue.push(e2);\n}\n\nvar contourId = 0;\n\nfunction processPolygon(polygon, isSubject, depth, queue, bbox) {\n  var i, len;\n  if (typeof polygon[0][0] === 'number') {\n    for (i = 0, len = polygon.length - 1; i < len; i++) {\n      processSegment(polygon[i], polygon[i + 1], isSubject, depth + 1, queue, bbox);\n    }\n  } else {\n    for (i = 0, len = polygon.length; i < len; i++) {\n      contourId++;\n      processPolygon(polygon[i], isSubject, contourId, queue, bbox);\n    }\n  }\n}\n\n\nfunction fillQueue(subject, clipping, sbbox, cbbox) {\n  var eventQueue = new Queue(null, compareEvents);\n  contourId = 0;\n\n  processPolygon(subject,  true,  0, eventQueue, sbbox);\n  processPolygon(clipping, false, 0, eventQueue, cbbox);\n\n  return eventQueue;\n}\n\n\nfunction computeFields(event, prev, sweepLine, operation) {\n  // compute inOut and otherInOut fields\n  if (prev === null) {\n    event.inOut      = false;\n    event.otherInOut = true;\n\n  // previous line segment in sweepline belongs to the same polygon\n  } else if (event.isSubject === prev.isSubject) {\n    event.inOut      = !prev.inOut;\n    event.otherInOut = prev.otherInOut;\n\n  // previous line segment in sweepline belongs to the clipping polygon\n  } else {\n    event.inOut      = !prev.otherInOut;\n    event.otherInOut = prev.isVertical() ? !prev.inOut : prev.inOut;\n  }\n\n  // compute prevInResult field\n  if (prev) {\n    event.prevInResult = (!inResult(prev, operation) || prev.isVertical()) ?\n       prev.prevInResult : prev;\n  }\n  // check if the line segment belongs to the Boolean operation\n  event.inResult = inResult(event, operation);\n}\n\n\nfunction inResult(event, operation) {\n  switch (event.type) {\n    case edgeType.NORMAL:\n      switch (operation) {\n        case INTERSECTION:\n          return !event.otherInOut;\n        case UNION:\n          return event.otherInOut;\n        case DIFFERENCE:\n          return (event.isSubject && event.otherInOut) ||\n                 (!event.isSubject && !event.otherInOut);\n        case XOR:\n          return true;\n      }\n    case edgeType.SAME_TRANSITION:\n      return operation === INTERSECTION || operation === UNION;\n    case edgeType.DIFFERENT_TRANSITION:\n      return operation === DIFFERENCE;\n    case edgeType.NON_CONTRIBUTING:\n      return false;\n  }\n  return false;\n}\n\n\n/**\n * @param  {SweepEvent} se1\n * @param  {SweepEvent} se2\n * @param  {Queue}      queue\n * @return {Number}\n */\nfunction possibleIntersection(se1, se2, queue) {\n  // that disallows self-intersecting polygons,\n  // did cost us half a day, so I'll leave it\n  // out of respect\n  // if (se1.isSubject === se2.isSubject) return;\n\n  var inter = intersection(\n    se1.point, se1.otherEvent.point,\n    se2.point, se2.otherEvent.point\n  );\n\n  var nintersections = inter ? inter.length : 0;\n  if (nintersections === 0) return 0; // no intersection\n\n  // the line segments intersect at an endpoint of both line segments\n  if ((nintersections === 1) &&\n      (equals(se1.point, se2.point) ||\n       equals(se1.otherEvent.point, se2.otherEvent.point))) {\n    return 0;\n  }\n\n  if (nintersections === 2 && se1.isSubject === se2.isSubject){\n    if(se1.contourId === se2.contourId){\n    console.warn('Edges of the same polygon overlap',\n      se1.point, se1.otherEvent.point, se2.point, se2.otherEvent.point);\n    }\n    //throw new Error('Edges of the same polygon overlap');\n    return 0;\n  }\n\n  // The line segments associated to se1 and se2 intersect\n  if (nintersections === 1) {\n\n    // if the intersection point is not an endpoint of se1\n    if (!equals(se1.point, inter[0]) && !equals(se1.otherEvent.point, inter[0])) {\n      divideSegment(se1, inter[0], queue);\n    }\n\n    // if the intersection point is not an endpoint of se2\n    if (!equals(se2.point, inter[0]) && !equals(se2.otherEvent.point, inter[0])) {\n      divideSegment(se2, inter[0], queue);\n    }\n    return 1;\n  }\n\n  // The line segments associated to se1 and se2 overlap\n  var events        = [];\n  var leftCoincide  = false;\n  var rightCoincide = false;\n\n  if (equals(se1.point, se2.point)) {\n    leftCoincide = true; // linked\n  } else if (compareEvents(se1, se2) === 1) {\n    events.push(se2, se1);\n  } else {\n    events.push(se1, se2);\n  }\n\n  if (equals(se1.otherEvent.point, se2.otherEvent.point)) {\n    rightCoincide = true;\n  } else if (compareEvents(se1.otherEvent, se2.otherEvent) === 1) {\n    events.push(se2.otherEvent, se1.otherEvent);\n  } else {\n    events.push(se1.otherEvent, se2.otherEvent);\n  }\n\n  if ((leftCoincide && rightCoincide) || leftCoincide) {\n    // both line segments are equal or share the left endpoint\n    se1.type = edgeType.NON_CONTRIBUTING;\n    se2.type = (se1.inOut === se2.inOut) ?\n      edgeType.SAME_TRANSITION :\n      edgeType.DIFFERENT_TRANSITION;\n\n    if (leftCoincide && !rightCoincide) {\n      // honestly no idea, but changing events selection from [2, 1]\n      // to [0, 1] fixes the overlapping self-intersecting polygons issue\n      divideSegment(events[0].otherEvent, events[1].point, queue);\n    }\n    return 2;\n  }\n\n  // the line segments share the right endpoint\n  if (rightCoincide) {\n    divideSegment(events[0], events[1].point, queue);\n    return 3;\n  }\n\n  // no line segment includes totally the other one\n  if (events[0] !== events[3].otherEvent) {\n    divideSegment(events[0], events[1].point, queue);\n    divideSegment(events[1], events[2].point, queue);\n    return 3;\n  }\n\n  // one line segment includes the other one\n  divideSegment(events[0], events[1].point, queue);\n  divideSegment(events[3].otherEvent, events[2].point, queue);\n\n  return 3;\n}\n\n\n/**\n * @param  {SweepEvent} se\n * @param  {Array.<Number>} p\n * @param  {Queue} queue\n * @return {Queue}\n */\nfunction divideSegment(se, p, queue)  {\n  var r = new SweepEvent(p, false, se,            se.isSubject);\n  var l = new SweepEvent(p, true,  se.otherEvent, se.isSubject);\n\n  if (equals(se.point, se.otherEvent.point)) {\n    console.warn('what is that?', se);\n  }\n\n  r.contourId = l.contourId = se.contourId;\n\n  // avoid a rounding error. The left event would be processed after the right event\n  if (compareEvents(l, se.otherEvent) > 0) {\n    se.otherEvent.left = true;\n    l.left = false;\n  }\n\n  // avoid a rounding error. The left event would be processed after the right event\n  // if (compareEvents(se, r) > 0) {}\n\n  se.otherEvent.otherEvent = l;\n  se.otherEvent = r;\n\n  queue.push(l);\n  queue.push(r);\n\n  return queue;\n}\n\n\n/* eslint-disable no-unused-vars, no-debugger */\nfunction iteratorEquals(it1, it2) {\n  return it1._cursor === it2._cursor;\n}\n\n\nfunction _renderSweepLine(sweepLine, pos, event) {\n  var map = window.map;\n  if (!map) return;\n  if (window.sws) window.sws.forEach(function(p) {\n    map.removeLayer(p);\n  });\n  window.sws = [];\n  sweepLine.each(function(e) {\n    var poly = L.polyline([e.point.slice().reverse(), e.otherEvent.point.slice().reverse()], { color: 'green' }).addTo(map);\n    window.sws.push(poly);\n  });\n\n  if (window.vt) map.removeLayer(window.vt);\n  var v = pos.slice();\n  var b = map.getBounds();\n  window.vt = L.polyline([[b.getNorth(), v[0]], [b.getSouth(), v[0]]], {color: 'green', weight: 1}).addTo(map);\n\n  if (window.ps) map.removeLayer(window.ps);\n  window.ps = L.polyline([event.point.slice().reverse(), event.otherEvent.point.slice().reverse()], {color: 'black', weight: 9, opacity: 0.4}).addTo(map);\n  debugger;\n}\n/* eslint-enable no-unused-vars, no-debugger */\n\n\nfunction subdivideSegments(eventQueue, subject, clipping, sbbox, cbbox, operation) {\n  var sortedEvents = [];\n  var prev, next;\n\n  var sweepLine = new Tree(compareSegments);\n  var sortedEvents = [];\n\n  var rightbound = min(sbbox[2], cbbox[2]);\n\n  var prev, next;\n\n  while (eventQueue.length) {\n    var event = eventQueue.pop();\n    sortedEvents.push(event);\n\n    // optimization by bboxes for intersection and difference goes here\n    if ((operation === INTERSECTION && event.point[0] > rightbound) ||\n        (operation === DIFFERENCE   && event.point[0] > sbbox[2])) {\n      break;\n    }\n\n    if (event.left) {\n      sweepLine.insert(event);\n      // _renderSweepLine(sweepLine, event.point, event);\n\n      next = sweepLine.findIter(event);\n      prev = sweepLine.findIter(event);\n      event.iterator = sweepLine.findIter(event);\n\n      // Cannot get out of the tree what we just put there\n      if (!prev || !next) {\n        console.log('brute');\n        var iterators = findIterBrute(sweepLine);\n        prev = iterators[0];\n        next = iterators[1];\n      }\n\n      if (prev.data() !== sweepLine.min()) {\n        prev.prev();\n      } else {\n        prev = sweepLine.iterator(); //findIter(sweepLine.max());\n        prev.prev();\n        prev.next();\n      }\n      next.next();\n\n      computeFields(event, prev.data(), sweepLine, operation);\n\n      if (next.data()) {\n        if (possibleIntersection(event, next.data(), eventQueue) === 2) {\n          computeFields(event, prev.data(), sweepLine, operation);\n          computeFields(event, next.data(), sweepLine, operation);\n        }\n      }\n\n      if (prev.data()) {\n        if (possibleIntersection(prev.data(), event, eventQueue) === 2) {\n          var prevprev = sweepLine.findIter(prev.data());\n          if (prevprev.data() !== sweepLine.min()) {\n            prevprev.prev();\n          } else {\n            prevprev = sweepLine.findIter(sweepLine.max());\n            prevprev.next();\n          }\n          computeFields(prev.data(), prevprev.data(), sweepLine, operation);\n          computeFields(event, prev.data(), sweepLine, operation);\n        }\n      }\n    } else {\n      event = event.otherEvent;\n      next = sweepLine.findIter(event);\n      prev = sweepLine.findIter(event);\n\n      // _renderSweepLine(sweepLine, event.otherEvent.point, event);\n\n      if (!(prev && next)) continue;\n\n      if (prev.data() !== sweepLine.min()) {\n        prev.prev();\n      } else {\n        prev = sweepLine.iterator();\n        prev.prev(); // sweepLine.findIter(sweepLine.max());\n        prev.next();\n      }\n      next.next();\n      sweepLine.remove(event);\n\n      //_renderSweepLine(sweepLine, event.otherEvent.point, event);\n\n      if (next.data() && prev.data()) {\n        possibleIntersection(prev.data(), next.data(), eventQueue);\n      }\n    }\n  }\n  return sortedEvents;\n}\n\nfunction findIterBrute(sweepLine, q) {\n  var prev = sweepLine.iterator();\n  var next = sweepLine.iterator();\n  var it   = sweepLine.iterator(), data;\n  while((data = it.next()) !== null) {\n    prev.next();\n    next.next();\n    if (data === event) {\n      break;\n    }\n  }\n  return [prev, next];\n}\n\n\nfunction swap (arr, i, n) {\n  var temp = arr[i];\n  arr[i] = arr[n];\n  arr[n] = temp;\n}\n\n\nfunction changeOrientation(contour) {\n  return contour.reverse();\n}\n\n\nfunction isArray (arr) {\n  return Object.prototype.toString.call(arr) === '[object Array]';\n}\n\n\nfunction addHole(contour, idx) {\n  if (isArray(contour[0]) && !isArray(contour[0][0])) {\n    contour = [contour];\n  }\n  contour[idx] = [];\n  return contour;\n}\n\n\n/**\n * @param  {Array.<SweepEvent>} sortedEvents\n * @return {Array.<SweepEvent>}\n */\nfunction orderEvents(sortedEvents) {\n  var event, i, len;\n  var resultEvents = [];\n  for (i = 0, len = sortedEvents.length; i < len; i++) {\n    event = sortedEvents[i];\n    if ((event.left && event.inResult) ||\n      (!event.left && event.otherEvent.inResult)) {\n      resultEvents.push(event);\n    }\n  }\n\n  // Due to overlapping edges the resultEvents array can be not wholly sorted\n  var sorted = false;\n  while (!sorted) {\n    sorted = true;\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      if ((i + 1) < len &&\n        compareEvents(resultEvents[i], resultEvents[i + 1]) === 1) {\n        swap(resultEvents, i, i + 1);\n        sorted = false;\n      }\n    }\n  }\n\n  for (i = 0, len = resultEvents.length; i < len; i++) {\n    resultEvents[i].pos = i;\n  }\n\n  for (i = 0, len = resultEvents.length; i < len; i++) {\n    if (!resultEvents[i].left) {\n      var temp = resultEvents[i].pos;\n      resultEvents[i].pos = resultEvents[i].otherEvent.pos;\n      resultEvents[i].otherEvent.pos = temp;\n    }\n  }\n\n  return resultEvents;\n}\n\n\n/**\n * @param  {Array.<SweepEvent>} sortedEvents\n * @return {Array.<*>} polygons\n */\nfunction connectEdges(sortedEvents) {\n  var i, len;\n  var resultEvents = orderEvents(sortedEvents);\n\n\n  // \"false\"-filled array\n  var processed = Array(resultEvents.length);\n  var result = [];\n\n  var depth  = [];\n  var holeOf = [];\n  var isHole = {};\n\n  for (i = 0, len = resultEvents.length; i < len; i++) {\n    if (processed[i]) continue;\n\n    var contour = [];\n    result.push(contour);\n\n    var ringId = result.length - 1;\n    depth.push(0);\n    holeOf.push(-1);\n\n\n    if (resultEvents[i].prevInResult) {\n      var lowerContourId = resultEvents[i].prevInResult.contourId;\n      if (!resultEvents[i].prevInResult.resultInOut) {\n        addHole(result[lowerContourId], ringId);\n        holeOf[ringId] = lowerContourId;\n        depth[ringId]  = depth[lowerContourId] + 1;\n        isHole[ringId] = true;\n      } else if (isHole[lowerContourId]) {\n        addHole(result[holeOf[lowerContourId]], ringId);\n        holeOf[ringId] = holeOf[lowerContourId];\n        depth[ringId]  = depth[lowerContourId];\n        isHole[ringId] = true;\n      }\n    }\n\n    var pos = i;\n    var initial = resultEvents[i].point;\n    contour.push(initial);\n\n    while (pos >= i) {\n      processed[pos] = true;\n\n      if (resultEvents[pos].left) {\n        resultEvents[pos].resultInOut = false;\n        resultEvents[pos].contourId   = ringId;\n      } else {\n        resultEvents[pos].otherEvent.resultInOut = true;\n        resultEvents[pos].otherEvent.contourId   = ringId;\n      }\n\n      pos = resultEvents[pos].pos;\n      processed[pos] = true;\n\n      contour.push(resultEvents[pos].point);\n      pos = nextPos(pos, resultEvents, processed);\n    }\n\n    pos = pos === -1 ? i : pos;\n\n    processed[pos] = processed[resultEvents[pos].pos] = true;\n    resultEvents[pos].otherEvent.resultInOut = true;\n    resultEvents[pos].otherEvent.contourId   = ringId;\n\n\n    // depth is even\n    /* eslint-disable no-bitwise */\n    if (depth[ringId] & 1) {\n      changeOrientation(contour);\n    }\n    /* eslint-enable no-bitwise */\n  }\n\n  return result;\n}\n\n\n/**\n * @param  {Number} pos\n * @param  {Array.<SweepEvent>} resultEvents\n * @param  {Array.<Boolean>}    processed\n * @return {Number}\n */\nfunction nextPos(pos, resultEvents, processed) {\n  var newPos = pos + 1;\n  var length = resultEvents.length;\n  while (newPos < length &&\n         equals(resultEvents[newPos].point, resultEvents[pos].point)) {\n    if (!processed[newPos]) {\n      return newPos;\n    } else {\n      newPos = newPos + 1;\n    }\n  }\n\n  newPos = pos - 1;\n\n  while (processed[newPos]) {\n    newPos = newPos - 1;\n  }\n  return newPos;\n}\n\n\nfunction trivialOperation(subject, clipping, operation) {\n  var result = null;\n  if (subject.length * clipping.length === 0) {\n    if (operation === INTERSECTION) {\n      result = EMPTY;\n    } else if (operation === DIFFERENCE) {\n      result = subject;\n    } else if (operation === UNION || operation === XOR) {\n      result = (subject.length === 0) ? clipping : subject;\n    }\n  }\n  return result;\n}\n\n\nfunction compareBBoxes(subject, clipping, sbbox, cbbox, operation) {\n  var result = null;\n  if (sbbox[0] > cbbox[2] ||\n      cbbox[0] > sbbox[2] ||\n      sbbox[1] > cbbox[3] ||\n      cbbox[1] > sbbox[3]) {\n    if (operation === INTERSECTION) {\n      result = EMPTY;\n    } else if (operation === DIFFERENCE) {\n      result = subject;\n    } else if (operation === UNION || operation === XOR) {\n      result = subject.concat(clipping);\n    }\n  }\n  return result;\n}\n\n\nfunction boolean(subject, clipping, operation) {\n  var trivial = trivialOperation(subject, clipping, operation);\n  if (trivial) {\n    return trivial === EMPTY ? null : trivial;\n  }\n  var sbbox = [Infinity, Infinity, -Infinity, -Infinity];\n  var cbbox = [Infinity, Infinity, -Infinity, -Infinity];\n\n  var eventQueue = fillQueue(subject, clipping, sbbox, cbbox);\n\n  trivial = compareBBoxes(subject, clipping, sbbox, cbbox, operation);\n  if (trivial) {\n    return trivial === EMPTY ? null : trivial;\n  }\n  var sortedEvents = subdivideSegments(eventQueue, subject, clipping, sbbox, cbbox, operation);\n  return connectEdges(sortedEvents);\n}\n\n\nmodule.exports = boolean;\n\n\nmodule.exports.union = function(subject, clipping) {\n  return boolean(subject, clipping, UNION);\n};\n\n\nmodule.exports.diff = function(subject, clipping) {\n  return boolean(subject, clipping, DIFFERENCE);\n};\n\n\nmodule.exports.xor = function(subject, clipping) {\n  return boolean(subject, clipping, XOR);\n};\n\n\nmodule.exports.intersection = function(subject, clipping) {\n  return boolean(subject, clipping, INTERSECTION);\n};\n\n\n/**\n * @enum {Number}\n */\nmodule.exports.operations = {\n  INTERSECTION: INTERSECTION,\n  DIFFERENCE:   DIFFERENCE,\n  UNION:        UNION,\n  XOR:          XOR\n};\n\n\n// for testing\nmodule.exports.fillQueue            = fillQueue;\nmodule.exports.computeFields        = computeFields;\nmodule.exports.subdivideSegments    = subdivideSegments;\nmodule.exports.divideSegment        = divideSegment;\nmodule.exports.possibleIntersection = possibleIntersection;\n","module.exports = require('./src/index');\n","/**\n * @param  {*} arr\n * @return {Boolean}\n */\nexport const isArray =\n  Array.isArray ||\n  function (arr) {\n    return Object.prototype.toString.call(arr) === '[object Array]';\n  };\n\n/**\n * @param  {*} arr\n * @return {Boolean}\n */\nexport const isNonEmptyArray = arr => isArray(arr) && arr.length;\n\n/**\n * @param  {Array.<Number>} p1\n * @param  {Array.<Number>} p2\n * @return {Boolean}\n */\nexport function equals(p1, p2) {\n  return p1[0] === p2[0] && p1[1] === p2[1];\n}\n\n/**\n * @param  {*}       coordinates\n * @param  {Number=} depth\n * @return {*}\n */\nexport function orientRings(coordinates, depth, isHole) {\n  depth = depth || 0;\n  let i, len;\n  if (isNonEmptyArray(coordinates) && typeof coordinates[0][0] === 'number') {\n    let area = 0;\n    const ring = coordinates;\n\n    for (i = 0, len = ring.length; i < len; i++) {\n      const pt1 = ring[i];\n      const pt2 = ring[(i + 1) % len];\n      area += pt1[0] * pt2[1];\n      area -= pt2[0] * pt1[1];\n    }\n    if ((!isHole && area > 0) || (isHole && area < 0)) {\n      ring.reverse();\n    }\n  } else {\n    for (i = 0, len = coordinates.length; i < len; i++) {\n      orientRings(coordinates[i], depth + 1, i > 0);\n    }\n  }\n\n  if (\n    depth === 0 &&\n    isNonEmptyArray(coordinates) &&\n    isNonEmptyArray(coordinates[0]) &&\n    typeof coordinates[0][0][0] === 'number'\n  ) {\n    const clone = coordinates[0].slice(0, 1)[0];\n    coordinates[0].pop();\n    coordinates[0].push([clone[0], clone[1]]);\n  }\n\n  return coordinates;\n}\n\n/**\n * Creates arch between two edges\n *\n * @param  {Array.<Object>} vertices\n * @param  {Object}         center\n * @param  {Number}         radius\n * @param  {Object}         startVertex\n * @param  {Object}         endVertex\n * @param  {Number}         segments\n * @param  {Boolean}        outwards\n */\nexport function arc(\n  vertices,\n  center,\n  radius,\n  startVertex,\n  endVertex,\n  segments,\n  outwards\n) {\n  const PI2 = Math.PI * 2;\n  let startAngle = Math.atan2(\n    startVertex[1] - center[1],\n    startVertex[0] - center[0]\n  );\n  let endAngle = Math.atan2(endVertex[1] - center[1], endVertex[0] - center[0]);\n\n  // odd number please\n  if (segments % 2 === 0) segments -= 1;\n\n  if (startAngle < 0) startAngle += PI2;\n\n  if (endAngle < 0) endAngle += PI2;\n\n  let angle =\n    startAngle > endAngle ? startAngle - endAngle : startAngle + PI2 - endAngle;\n  const segmentAngle = (outwards ? -angle : PI2 - angle) / segments;\n\n  vertices.push(startVertex);\n  for (let i = 1; i < segments; ++i) {\n    angle = startAngle + segmentAngle * i;\n    vertices.push([\n      center[0] + Math.cos(angle) * radius,\n      center[1] + Math.sin(angle) * radius\n    ]);\n  }\n  vertices.push(endVertex);\n  return vertices;\n}\n\n/**\n * @param  {Array.<Array.<Number>>} vertices\n * @param  {Array.<Number>}         pt1\n * @param  {Array.<Number>}         pt2\n * @param  {Number}                 dist\n * @param  {Number}                 arcSegments\n * @return {Array.<Array.<Number>>}\n */\nexport function offsetSegment(v1, v2, e1, dist, arcSegments) {\n  const vertices = [];\n  const offsets = [\n    e1.offset(e1.inNormal[0] * dist, e1.inNormal[1] * dist),\n    e1.inverseOffset(e1.outNormal[0] * dist, e1.outNormal[1] * dist)\n  ];\n\n  for (let i = 0, len = 2; i < len; i++) {\n    const thisEdge = offsets[i];\n    const prevEdge = offsets[(i + len - 1) % len];\n    arc(\n      vertices,\n      i === 0 ? v1 : v2, // edges[i].current, // p1 or p2\n      dist,\n      prevEdge.next,\n      thisEdge.current,\n      arcSegments,\n      true\n    );\n  }\n\n  return vertices;\n}\n\n/**\n * @param  {Array.<Object>} vertices\n * @return {Array.<Object>}\n */\nexport function ensureLastPoint(vertices) {\n  if (!equals(vertices[0], vertices[vertices.length - 1])) {\n    vertices.push([vertices[0][0], vertices[0][1]]);\n  }\n  return vertices;\n}\n","import Edge from './edge';\nimport martinez from 'martinez-polygon-clipping';\nimport {\n  isArray,\n  equals,\n  orientRings,\n  offsetSegment,\n  ensureLastPoint\n} from './utils';\n\n/**\n * Offset builder\n *\n * @param {Array.<Object>=} vertices\n * @param {Number=}        arcSegments\n */\nexport default class Offset {\n  constructor(vertices, arcSegments = 5) {\n    /**\n     * @type {Array.<Object>}\n     */\n    this.vertices = null;\n\n    /**\n     * @type {Array.<Edge>}\n     */\n    this.edges = null;\n\n    /**\n     * @type {Boolean}\n     */\n    this._closed = false;\n\n    /**\n     * @type {Number}\n     */\n    this._distance = 0;\n\n    if (vertices) {\n      this.data(vertices);\n    }\n\n    /**\n     * Segments in edge bounding arches\n     * @type {Number}\n     */\n    this._arcSegments = arcSegments;\n  }\n\n  /**\n   * Change data set\n   * @param  {Array.<Array>} vertices\n   * @return {Offset}\n   */\n  data(vertices) {\n    this._edges = [];\n    if (!isArray(vertices)) {\n      throw new Error('Offset requires at least one coodinate to work with');\n    }\n\n    if (isArray(vertices) && typeof vertices[0] === 'number') {\n      this.vertices = vertices;\n    } else {\n      this.vertices = orientRings(vertices);\n      this._processContour(this.vertices, this._edges);\n    }\n\n    return this;\n  }\n\n  /**\n   * Recursively process contour to create normals\n   * @param  {*} contour\n   * @param  {Array} edges\n   */\n  _processContour(contour, edges) {\n    let i, len;\n    if (isArray(contour[0]) && typeof contour[0][0] === 'number') {\n      len = contour.length;\n      if (equals(contour[0], contour[len - 1])) {\n        len -= 1; // otherwise we get division by zero in normals\n      }\n      for (i = 0; i < len; i++) {\n        edges.push(new Edge(contour[i], contour[(i + 1) % len]));\n      }\n    } else {\n      for (i = 0, len = contour.length; i < len; i++) {\n        edges.push([]);\n        this._processContour(contour[i], edges[edges.length - 1]);\n      }\n    }\n  }\n\n  /**\n   * @param  {Number} arcSegments\n   * @return {Offset}\n   */\n  arcSegments(arcSegments) {\n    this._arcSegments = arcSegments;\n    return this;\n  }\n\n  /**\n   * Validates if the first and last points repeat\n   * TODO: check CCW\n   *\n   * @param  {Array.<Object>} vertices\n   */\n  validate(vertices) {\n    const len = vertices.length;\n    if (typeof vertices[0] === 'number') return [vertices];\n    if (\n      vertices[0][0] === vertices[len - 1][0] &&\n      vertices[0][1] === vertices[len - 1][1]\n    ) {\n      if (len > 1) {\n        vertices = vertices.slice(0, len - 1);\n        this._closed = true;\n      }\n    }\n    return vertices;\n  }\n\n  /**\n   * @param  {Number}  dist\n   * @param  {String=} units\n   * @return {Offset}\n   */\n  distance(dist, units) {\n    this._distance = dist || 0;\n    return this;\n  }\n\n  /**\n   * Decides by the sign if it's a padding or a margin\n   *\n   * @param  {Number} dist\n   * @return {Array.<Object>}\n   */\n  offset(dist) {\n    this.distance(dist);\n    return this._distance === 0\n      ? this.vertices\n      : this._distance > 0\n        ? this.margin(this._distance)\n        : this.padding(-this._distance);\n  }\n\n  /**\n   * @param  {Number} dist\n   * @return {Array.<Number>}\n   */\n  margin(dist) {\n    this.distance(dist);\n\n    if (typeof this.vertices[0] === 'number') {\n      // point\n      return this.offsetPoint(this._distance);\n    }\n\n    if (dist === 0) return this.vertices;\n\n    let union = this.offsetLines(this._distance);\n    //return union;\n    union = martinez.union(this.vertices, union);\n    return orientRings(union);\n  }\n\n  /**\n   * @param  {Number} dist\n   * @return {Array.<Number>}\n   */\n  padding(dist) {\n    this.distance(dist);\n\n    if (this._distance === 0) return ensureLastPoint(this.vertices);\n    if (this.vertices.length === 2 && typeof this.vertices[0] === 'number') {\n      return this.vertices;\n    }\n\n    const union = this.offsetLines(this._distance);\n    const diff = martinez.diff(this.vertices, union);\n    return orientRings(diff);\n  }\n\n  /**\n   * Creates margin polygon\n   * @param  {Number} dist\n   * @return {Array.<Object>}\n   */\n  offsetLine(dist) {\n    if (dist === 0) return this.vertices;\n    return orientRings(this.offsetLines(dist));\n  }\n\n  /**\n   * Just offsets lines, no fill\n   * @param  {Number} dist\n   * @return {Array.<Array.<Array.<Number>>>}\n   */\n  offsetLines(dist) {\n    if (dist < 0) throw new Error('Cannot apply negative margin to the line');\n    let union;\n    this.distance(dist);\n    if (isArray(this.vertices[0]) && typeof this.vertices[0][0] !== 'number') {\n      for (let i = 0, len = this._edges.length; i < len; i++) {\n        union =\n          i === 0\n            ? this.offsetContour(this.vertices[i], this._edges[i])\n            : martinez.union(\n              union,\n              this.offsetContour(this.vertices[i], this._edges[i])\n            );\n      }\n    } else {\n      union =\n        this.vertices.length === 1\n          ? this.offsetPoint()\n          : this.offsetContour(this.vertices, this._edges);\n    }\n\n    return union;\n  }\n\n  /**\n   * @param  {Array.<Array.<Number>>|Array.<Array.<...>>} curve\n   * @param  {Array.<Edge>|Array.<Array.<...>>} edges\n   * @return {Polygon}\n   */\n  offsetContour(curve, edges) {\n    let union, i, len;\n    if (isArray(curve[0]) && typeof curve[0][0] === 'number') {\n      // we have 1 less edge than vertices\n      for (i = 0, len = curve.length - 1; i < len; i++) {\n        const segment = ensureLastPoint(\n          offsetSegment(\n            curve[i],\n            curve[i + 1],\n            edges[i],\n            this._distance,\n            this._arcSegments\n          )\n        );\n        union =\n          i === 0\n            ? [ensureLastPoint(segment)]\n            : martinez.union(union, ensureLastPoint(segment));\n      }\n    } else {\n      for (i = 0, len = edges.length; i < len; i++) {\n        union =\n          i === 0\n            ? this.offsetContour(curve[i], edges[i])\n            : martinez.union(union, this.offsetContour(curve[i], edges[i]));\n      }\n    }\n    return union;\n  }\n\n  /**\n   * @param  {Number} distance\n   * @return {Array.<Array.<Number>}\n   */\n  offsetPoint(distance) {\n    this.distance(distance);\n    let vertices = this._arcSegments * 2;\n    const points = [];\n    const center = this.vertices;\n    const radius = this._distance;\n    let angle = 0;\n\n    if (vertices % 2 === 0) vertices++;\n\n    for (let i = 0; i < vertices; i++) {\n      angle += (2 * Math.PI) / vertices; // counter-clockwise\n      points.push([\n        center[0] + radius * Math.cos(angle),\n        center[1] + radius * Math.sin(angle)\n      ]);\n    }\n\n    return orientRings([ensureLastPoint(points)]);\n  }\n}\n\nOffset.orientRings = orientRings;\n"],"names":["const","Edge","current","next","this","inNormal","inwardsNormal","outNormal","dx","dy","edgeLength","Math","sqrt","Error","offset","offsetEdge","inverseOffset","inverse","TinyQueue","data","compare","length","defaultCompare","i","_down","a","b","TreeBase","Iterator","tree","_tree","_ancestors","_cursor","prototype","push","item","_up","pop","top","peek","pos","parent","halfLength","left","right","best","clear","_root","size","find","res","c","_comparator","get_child","findIter","iter","iterator","lowerBound","cur","cmp","upperBound","min","max","each","cb","it","reach","prev","root","_minNode","save","_maxNode","start","Node","red","RBTree","comparator","is_red","node","single_rotate","dir","set_child","double_rotate","val","insert","ret","head","undefined","last","gp","ggp","p","dir2","remove","found","sr","sibling","gpc","BinTree","require$$0","p0","p1","p2","SweepEvent","point","otherEvent","isSubject","edgeType","type","EdgeType","inOut","otherInOut","prevInResult","inResult","resultInOut","isBelow","signedArea","isAbove","isVertical","e1","e2","specialCases","le1","le2","equals","compareEvents","contourId","krossProduct","dotProduct","EMPTY","Tree","processSegment","s1","s2","depth","eventQueue","bbox","processPolygon","polygon","queue","len","fillQueue","subject","clipping","sbbox","cbbox","Queue","computeFields","event","sweepLine","operation","possibleIntersection","se1","se2","inter","a1","a2","b1","b2","noEndpointTouch","va","vb","toPoint","s","d","e","kross","sqrKross","sqrLenA","t","sqrLenE","sa","sb","smin","smax","intersection","nintersections","console","warn","divideSegment","events","leftCoincide","rightCoincide","se","r","l","subdivideSegments","sortedEvents","compareSegments","rightbound","log","iterators","findIterBrute","prevprev","q","swap","arr","n","temp","changeOrientation","contour","reverse","isArray","Object","toString","call","addHole","idx","connectEdges","resultEvents","sorted","orderEvents","processed","Array","result","holeOf","isHole","ringId","lowerContourId","initial","nextPos","newPos","boolean","trivial","trivialOperation","Infinity","concat","compareBBoxes","INTERSECTION","DIFFERENCE","UNION","XOR","isNonEmptyArray","orientRings","coordinates","let","area","ring","pt1","pt2","clone","slice","arc","vertices","center","radius","startVertex","endVertex","segments","outwards","PI2","PI","startAngle","atan2","endAngle","angle","segmentAngle","cos","sin","offsetSegment","v1","v2","dist","arcSegments","offsets","thisEdge","ensureLastPoint","Offset","edges","_closed","_distance","_arcSegments","_edges","_processContour","validate","distance","units","margin","padding","offsetPoint","union","offsetLines","martinez","diff","offsetLine","offsetContour","curve","segment","points"],"mappings":"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"}